/*==============================================================================
== FILENAME : main.c
== FAT file system for Atmega 32 
================================================================================
==
== FILE NAME :
==    main.c
==
== Description : Made following changes to the Fat File System library

== Step1- Changed Buffer Size from 2048 bytes to 128 bytes,can be changed further according to need.
== Step2- RTC.h is replaced with STIME.h
== Step3- Using TIMER2_COMP_vect(called after every 1ms) for asyncronous timer operation(for RTC)
== Step4- Using TIMER0_COMP_vect(called after every 10ms) for
	(i) incrementing the timer variable(so declared as volatile)
	(ii)calling disk_timerproc function for checking the disk status(write protected or not,inserted to socket or not)
== Step5- Ports configured according to ATmega 32 configuration, removing the ones that are used in ATmega128 but not in ATMega32.Also,
	(i)SPI function is enabled through initialising SPI port.
	(ii)ASSR register is added for asyncronous timer operation.
== Step6- f_mkfs is added(for making filesystem),thus adding functionality of being able to format from the board, without the need to use PC for it.
== Step7- The size of linebuff is reduced to 16 bytes from 120 bytes.
== Step8- Removed acc_size,acc_files,acc_dirs variables used in scan_files called in file status check case. 
== Step9- Removed put_dump function along with the cases accessing this function-
    (1)showing disk status,
    (2)dumping the sector's data on to the terminal,
    (3)dumping read/write buffer's data on to the terminal,
    (4)dumping current file's data on to the terminal. 
== Step10- Removed low level disk operations(which stands for writing to or reading from the disk without using FAT module) 
== Step11- Removed the following functionalities,as were not required-
  (1)Truncating file,
  (2)Changing file/dir name,
  (3)Creating a directory,
  (4)Changing file/dir attribute,
  (5)copying files,
  (6)timestamping files.
== Step12- commented all RTC related functions and declarations for future consideration and changes.  


== DATE         NAME              REASON
== ----         ----              ------
== June2008   Sweta Yadav     Implementing file storing on Atmega32 
==
==============================================================================*/


#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <string.h>
#include "uart.h"
#include "xitoa.h"
#include "tff.h"
#include "diskio.h"
#include "stime.h"



FILINFO finfo;

BYTE linebuf[16];			/* Console input buffer */

FATFS fatfs;				/* File system object for each logical drive */
BYTE Buff[128];			/* Working buffer */


volatile WORD Timer;		/* 100Hz increment timer */
time_t rtc = 1144713600;	/* Real Time Clock (start at 2006/4/11) */


/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/


ISR(TIMER0_COMP_vect)
{
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}
/*---------------------------------------------------------*/
/* 10Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/

ISR(TIMER2_COMP_vect)
{
rtc++;
}

/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */
/* This is not required in read-only configuration.        */


DWORD get_fattime ()
{
	//RTC rtc;


	//rtc_gettime(&rtc);
	struct tm *tmr;
	time_t t;


	cli();
	t = rtc;
	sei();
	tmr = gmtime(&t);
	return	  ((DWORD)(tmr->tm_year - 80) << 25)
			| ((DWORD)(tmr->tm_mon + 1) << 21)
			| ((DWORD)tmr->tm_mday << 16)
			| (WORD)(tmr->tm_hour << 11)
			| (WORD)(tmr->tm_min << 5)
			| (WORD)(tmr->tm_sec >> 1);

	//return	  ((DWORD)(rtc.year - 1980) << 25)
			//| ((DWORD)rtc.month << 21)
			//| ((DWORD)rtc.mday << 16)
			//| ((DWORD)rtc.hour << 11)
			//| ((DWORD)rtc.min << 5)
			//| ((DWORD)rtc.sec >> 1);
}


/*--------------------------------------------------------------------------*/
/* Monitor                                                                  */



static
void get_line (char *buff, int len)
{
	char c;
	int idx = 0;


	for (;;) {
		c = uart_get();
		if (c == '\r') break;
		if ((c == '\b') && idx) {
			idx--; uart_put(c);
		}
		if (((BYTE)c >= ' ') && (idx < len - 1)) {
				buff[idx++] = c; uart_put(c);
		}
	}
	buff[idx] = 0;
	uart_put(c);
	xputc('\n');
}


static
void put_rc (FRESULT rc)
{
	const prog_char *p;
	static const prog_char str[] =
		"OK\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0" "INVALID_NAME\0" "INVALID_DRIVE\0"
		"DENIED\0" "EXIST\0" "RW_ERROR\0" "WRITE_PROTECTED\0" "NOT_ENABLED\0"
		"NO_FILESYSTEM\0" "INVALID_OBJECT\0" "MKFS_ABORTED\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && pgm_read_byte_near(p); i++) {
		while(pgm_read_byte_near(p++));
	}
	xprintf(PSTR("rc=%u FR_%S\n"), (WORD)rc, p);
}




static
void IoInit ()
{
	PORTA = 0b11111111;	// Port A
    PORTB = 0b10110111;			/* Enable drivers */
    DDRB = 0b10110000;
	
	
	SPCR = 0b01011110 ;  //clock must not exceed 400 kHz for initialization         
    SPSR = 1;            //turn on SPI2x clock

	PORTC = 0b11111111;	// Port C

	PORTD = 0b11111110; // Port D
    DDRD  = 0b00000010;
	
	uart_init();		// Initialize UART driver


	
	ASSR = 0b00001000;	// Timer2: 1Hz async operation (OC2)

    OCR2 =  128-1;	

	TCCR2 = 0b00001110;

	
    OCR0 =  90-1;             //Timer0: 100Hz interval (OC0)  
	TCCR0 = 0b0001101; 

    TIMSK = 0b10000010;	
	sei();
}



/*-----------------------------------------------------------------------*/
/* Main                                                                  */



int main ()
{
	char *ptr, *ptr2;
	DWORD p1, p2, p3;
	BYTE res, b1;
	WORD w1;
	UINT s1, s2, cnt;
	FATFS *fs;
	DIR dir;				
	FIL file1, file2;		
    IoInit();

	/* Join xitoa module to uart module */
	xfunc_out = (void (*)(char))uart_put;

	xputs(PSTR("tinyfat filesysten for debugging"));

	for (;;) {
		xputs(PSTR(">"));
		ptr = linebuf;
		get_line(ptr, sizeof(linebuf));

		switch (*ptr++) {

		case 'd' :
			switch (*ptr++) {
			
			case 'i' :	/* di - Initialize disk */
				xprintf(PSTR("rc=%d\n"), (WORD)disk_initialize(0));
				break;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                
			}
			break;

		case 'f' :
			switch (*ptr++) {

			case 'i' :	/* fi - Initialize logical drive */
				put_rc(f_mount(0, &fatfs));
				break;

			
			case 'l' :	/* fl [<path>] - Directory listing */
				res = f_opendir(&dir, ptr);
				if (res) { put_rc(res); break; }
				p1 = s1 = s2 = 0;
				for(;;) {
					res = f_readdir(&dir, &finfo);
					if ((res != FR_OK) || !finfo.fname[0]) break;
					if (finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += finfo.fsize;
					}
					xprintf(PSTR("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9lu  %s\n"), 
								(finfo.fattrib & AM_DIR) ? 'D' : '-',
								(finfo.fattrib & AM_RDO) ? 'R' : '-',
								(finfo.fattrib & AM_HID) ? 'H' : '-',
								(finfo.fattrib & AM_SYS) ? 'S' : '-',
								(finfo.fattrib & AM_ARC) ? 'A' : '-',
								(finfo.fdate >> 9) + 1980, (finfo.fdate >> 5) & 15, finfo.fdate & 31,
								(finfo.ftime >> 11), (finfo.ftime >> 5) & 63,
								finfo.fsize, &(finfo.fname[0]));
				}
				xprintf(PSTR("%4u File(s),%10lu bytes total\n%4u Dir(s)"), s1, p1, s2);
				if (f_getfree(ptr, &p1, &fs) == FR_OK)
					xprintf(PSTR(", %10luK bytes free\n"), p1 * fs->csize / 2);
				break;

			case 'o' :	/* fo <mode> <name> - Open a file */
				if (!xatoi(&ptr, &p1)) break;
				put_rc(f_open(&file1, ptr, (BYTE)p1));
				break;

			case 'c' :	/* fc - Close a file */
				put_rc(f_close(&file1));
				break;

			case 'e' :	/* fe - Seek file pointer */
				if (!xatoi(&ptr, &p1)) break;
				res = f_lseek(&file1, p1);
				put_rc(res);
				if (res == FR_OK)
					xprintf(PSTR("ptr = %lu"), file1.fptr, file1.fptr);
				break;

			case 'r' :	/* fr <len> - read file */
				if (!xatoi(&ptr, &p1)) break;
				p2 = 0;
				Timer = 0;
				while (p1) {
					if (p1 >= sizeof(Buff))	{ cnt = sizeof(Buff); p1 -= sizeof(Buff); }
					else 			{ cnt = (WORD)p1; p1 = 0; }
					res = f_read(&file1, Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				s2 = Timer;
				xprintf(PSTR("%lu"), p2 * 100 / s2);//reading speed
				break;

			
			case 'w' :	/* fw <len> <val> - write file */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2)) break;
				memset(Buff, (BYTE)p2, sizeof(Buff));
				p2 = 0;
				Timer = 0;
				while (p1) {
			if (p1 >= sizeof(Buff))	{ cnt = sizeof(Buff); p1 -= sizeof(Buff); }
					else 			{ cnt = (WORD)p1; p1 = 0; }
					res = f_write(&file1, Buff, cnt, &s2);
					if (res != FR_OK) { put_rc(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				s2 = Timer;
				xprintf(PSTR("%lu"), p2 * 100 / s2);//writing speed
				break;
				

			case 'u' :	/* fu <name> - Unlink a file or dir */
				put_rc(f_unlink(ptr));
				break;

				
#if _USE_MKFS
			case 'm' :	/* fm <logi drv#> <part type> <bytes/clust> - Create file system */
				if (!xatoi(&ptr, &p1) || !xatoi(&ptr, &p2) || !xatoi(&ptr, &p3)) break;
				xprintf(PSTR("drive will be formatted.sure? (Y/n)="), (WORD)p1);
				get_line(ptr, sizeof(linebuf));
				if (*ptr == 'Y') put_rc(f_mkfs((BYTE)p1, (BYTE)p2, (WORD)p3));
				break;
#endif
			}
			break;

		//case 't' :	/* t [<year> <mon> <mday> <hour> <min> <sec>] */
			//if (xatoi(&ptr, &p1)) {
				//rtc.year = (WORD)p1;
				//xatoi(&ptr, &p1); rtc.month = (BYTE)p1;
				//xatoi(&ptr, &p1); rtc.mday = (BYTE)p1;
				//xatoi(&ptr, &p1); rtc.hour = (BYTE)p1;
				//xatoi(&ptr, &p1); rtc.min = (BYTE)p1;
				//if (!xatoi(&ptr, &p1)) break;
				//rtc.sec = (BYTE)p1;
				//rtc_settime(&rtc);
			//}
			//rtc_gettime(&rtc);
			//xprintf(PSTR("%u/%u/%u %02u:%02u:%02u\n"), rtc.year, rtc.month, rtc.mday, rtc.hour, rtc.min, rtc.sec);
			//break;
		}
	}

}


